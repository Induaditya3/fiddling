\begin{algorithm}
    \caption{Ray Tracing Algorithm}
    \begin{algorithmic}[1]
        \STATE Initialize scene with objects and lights
        \STATE Set canvas resolution (width, height)
        \STATE For each pixel (x, y) in the canvas:
            \STATE \quad Generate ray from camera through pixel (x, y)
            \STATE \quad Initialize color to background color
            \STATE \quad Initialize closest intersection distance to infinity
            \STATE \quad For each object in the scene:
                \STATE \quad \quad If ray intersects object:
                    \STATE \quad \quad \quad Calculate intersection point
                    \STATE \quad \quad \quad Calculate normal at intersection point
                    \STATE \quad \quad \quad Calculate distance to intersection
                    \STATE \quad \quad \quad If distance is less than closest intersection distance:
                        \STATE \quad \quad \quad \quad Update closest intersection distance
                        \STATE \quad \quad \quad \quad Calculate color at intersection point
                        \STATE \quad \quad \quad \quad Update color based on lighting
            \STATE \quad Set pixel color to calculated color
        \STATE Render the image
    \end{algorithmic}
\end{algorithm}

Algorithm 

function calculateDiffuseIntensity(normalVector, lightVector, incomingIntensity) 
    // Calculate the dot product of the normal vector and the light vector
    dotProduct = calculateDotProduct(normalVector, lightVector) 
    
    // Initialize diffuse intensity
    diffuseIntensity = 0.0 
    
    // Check if the dot product is greater than zero
    if dotProduct > 0 then 
        // Calculate the diffuse intensity based on the incoming intensity and the angle between the vectors
        diffuseIntensity = incomingIntensity + (incomingIntensity * dotProduct) / (calculateMagnitude(lightVector) * calculateMagnitude(normalVector))
    else 
        // If the dot product is not greater than zero, keep the diffuse intensity as the initial value
        diffuseIntensity = incomingIntensity 
    end if 
    
    // Return the calculated diffuse intensity
    return diffuseIntensity 
end function



    

\begin{figure}[htbp]
    \centerline{\includegraphics[width=0.38\textwidth]{./figs/intensity.png}}
    \caption{Intensity after diffuse reflection}
\end{figure}
















$$



Algorithm 

function calculateSpecularIntensity(observerPosition, intersectionPoint, normalVector, lightDirection, lightIntensity, shininess, currentIntensity) 
    reflectedRay = calculateReflectedRay(normalVector, lightDirection) 
    viewVector = subtractVectors(observerPosition, intersectionPoint) 
    reflectionViewDotProduct = dotProduct(reflectedRay, viewVector) 
    specularIntensity = 0.0 

    if reflectionViewDotProduct > 0.0 and shininess > 0 then 
        specularIntensity = currentIntensity + lightIntensity * (reflectionViewDotProduct / (vectorMagnitude(reflectedRay) * vectorMagnitude(viewVector))) ^ shininess 
    else 
        specularIntensity = currentIntensity 
    end if

    return specularIntensity 
end function













Algorithm

function tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList, currentIntensity) 
    if lightList is not empty then 
        lightSource = lightList[0] // Get the first light source
        remainingLights = lightList[1:] // Get the rest of the light sources

        cumulativeIntensity = 0.0 
        maxDistance = 0.0 

        if lightSource.type == 'ambient' then 
            cumulativeIntensity = lightSource.intensity + cumulativeIntensity 
        else 
            lightDirection = {x: 0.0, y: 0.0, z: 0.0} 
            if lightSource.type == 'point' then 
                lightDirection = subtractVectors(lightSource.position, intersectionPoint) 
                maxDistance = 1.0 
            else 
                lightDirection = lightSource.position 
                maxDistance = infinity 
            end if

            shadowSphere, _ = findClosestSphere(intersectionPoint, lightDirection, 0.0001, maxDistance, sphereList) 

            if shadowSphere is None then 
                unitNormalVector = scaleVector(1.0 / vectorMagnitude(normalVector), normalVector) 
                cumulativeIntensity = calculateSpecularIntensity(observerPosition, intersectionPoint, unitNormalVector, lightDirection, lightSource.intensity, surfaceProperties, cumulativeIntensity) 
                cumulativeIntensity = calculateDiffuseIntensity(normalVector, lightDirection, lightSource.intensity, cumulativeIntensity) 
            end if
        end if

        return tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, remainingLights, sphereList, currentIntensity + cumulativeIntensity) 
    else 
        return currentIntensity 
    end if
end function

function til(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList) 
    return tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList, 0.0) 
end function


    normalVector: The normal vector at the intersection point.
    intersectionPoint: The point where the ray intersects the surface.
    observerPosition: The position of the observer (camera).
    surfaceProperties: Properties of the surface being shaded.
    lightList: A list of light sources affecting the scene.
    sphereList: A list of spheres in the scene.
    currentIntensity: The accumulated intensity of light at the intersection point.
    lightSource: The current light source being processed.
    remainingLights: The remaining light sources after the first one.
    cumulativeIntensity: The intensity contributed by the current light source.
    maxDistance: The maximum distance for shadow calculations.
    lightDirection: The direction vector from the light source to the intersection point.
    shadowSphere: The closest sphere found in the shadow calculation.
    unitNormalVector: The normalized normal vector at the intersection point.
    calculateSpecularIntensity: A function that calculates the specular intensity contribution.
    calculateDiffuseIntensity: A function that calculates the diffuse intensity contribution.
    findClosestSphere: A function that finds the closest sphere to a point in a given direction.


Ray tracing algorithm

function extract(sphereOption, intensity) 
    if sphereOption is Some sphere then 
        return intensity
    else 
        return 0.0
    end if
end function

function rayTraceInner(origin, direction, minDistance, maxDistance, sceneLights, lightList, recursionLimit) 
    objIntensity = 0.0 
    otherIntensity = 0.0 

    closestSphere, intersectionParameter = findClosestSphere(origin, direction, minDistance, maxDistance, sceneLights)

    if closestSphere is Some sphere and intersectionParameter is Some tParameter then 
        intersectionPoint = addVectors(origin, scaleVector(tParameter, direction)) 
        normalVector = subtractVectors(intersectionPoint, sphere.center) 
        objIntensity = calculateLightIntensity(normalVector, intersectionPoint, origin, sphere.surfaceReflectivity, lightList, sceneLights)

        if sphere.reflectionCoefficient > 0.0 and recursionLimit > 0 then 
            reflectedRay = calculateReflectedRay(scaleVector(1.0 / vectorMagnitude(normalVector), normalVector), scaleVector(-1.0, direction)) 
            otherIntensity = extract(rayTraceInner(intersectionPoint, reflectedRay, 0.001, infinity, sceneLights, lightList, recursionLimit - 1))
            objIntensity = objIntensity * (1.0 - sphere.reflectionCoefficient) + sphere.reflectionCoefficient * otherIntensity
        end if
    end if 

    return closestSphere, objIntensity
end function

function rayTrace(origin, direction, minDistance, maxDistance, sceneLights, lightList) 
    return getSphereColor(rayTraceInner(origin, direction, minDistance, maxDistance, sceneLights, lightList, 3))
end function

Explanation of Variables:

    sphereOption: Represents an optional sphere object.
    intensity: The intensity of light at a point.
    origin: The starting point of the ray.
    direction: The direction of the ray.
    minDistance: The minimum distance for ray intersection.
    maxDistance: The maximum distance for ray intersection.
    sceneLights: The lights present in the scene.
    lightList: A list of lights affecting the scene.
    recursionLimit: The maximum number of recursive reflections allowed.
    closestSphere: The closest sphere found in the scene.
    intersectionParameter: The parameter at which the ray intersects the sphere.
    intersectionPoint: The point where the ray intersects the sphere.
    normalVector: The normal vector at the intersection point.
    objIntensity: The intensity of light from the object.
    otherIntensity: The intensity of light from reflections.
    reflectedRay: The direction of the reflected ray.
    getSphereColor: A function that retrieves the color of the sphere based on the computed intensity.
