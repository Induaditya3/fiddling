Introduction

There are two approaches to rendering a three-dimensional scene: object-order rendering and image-order rendering. Object-order rendering involves iterating over each object and figuring out which set of pixels it maps to and coloring those pixels. In image-order rendering, for each pixel, the nearest visible object is found, and that pixel is colored using the given shading model. The former is classified into rasterization algorithms (or projective algorithms), and the latter is termed the ray tracing algorithm (image-space algorithm). Same effects, like reflections and shadows, are easy to implement in ray tracing compared to rasterization.

In ray tracing, image synthesis happens by shooting rays that go through the projection plane, and the nearest intersection with an object is found. If the object is reflective, rays bounce off it and hit other objects, which also influences color according to the shading model. In the current implementation, we have utilized the simplest shading model called Blinn-Phong shading and used the simplest three-dimensional geometrical object, a sphere, to illustrate ray tracing in the functional programming paradigm. To this end, we decided to use OCaml for its strong support for functional programming and its mechanisms to write imperative code as well, which will enable us to demonstrate alternative ways in the same programming language.

Methodlogy

Blinn-Phong Shading Model 

Diffuse Reflections 
Now, we will calculate the illumination of a point by both a point source and a directional source through diffuse reflection.

Consider a point $ P $ in the scene, with $ \vec{N} $ representing the normal vector at $ P $ and $ \vec{L} $ as the directional vector of the light source. For directional light, $ \vec{L} $ is provided. However, for a point light source, we need to compute $ \vec{L} $ based on the position of the light source and the coordinates of point $ P $. Let $ l $ denote the width of the light (which is proportional to its intensity) and $ x $ denote the distance over which the light spreads. The line $ RS $ is perpendicular to $ \vec{L} $, and $ Q $ is the point of intersection.

The ratio $ \frac{l}{x} $ represents the drop in intensity after the light reflects off the surface. For instance, if the light is perpendicular to point $ P $ on the surface, then $ \frac{l}{x} = 1 $.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{./figs/intensity.png}
    \caption{Intensity after reflection}
\end{figure}

Consider the right triangle $ \triangle PQR $. It is evident that 

$$\angle PRQ = \beta.$$

Using the definition of cosine in a right triangle, we have:

$$\cos \beta = \frac{l/2}{x/2} = \frac{l}{x}.$$

We also know that the dot product of the vectors can be expressed as:

$$\langle \vec{L}, \vec{N} \rangle = \|\vec{L}\| \|\vec{N}\| \cos \beta.$$

Thus, we can rewrite $ \cos \beta $ as:

$$\cos \beta = \frac{\langle \vec{L}, \vec{N} \rangle}{\|\vec{L}\| \|\vec{N}\|}.$$

If $ \beta > 90^\circ $, the point is illuminated from the backside of the surface, and in this case, we treat the intensity as zero.

To obtain the intensity after reflection, we multiply the intensity of the light by the factor $ \cos \beta $.

In a scene, a single point can be illuminated by multiple light sources, which may vary in type. We simply sum the intensities of all the light sources that reach the point and then multiply the total intensity by the color of the point, which effectively adjusts the brightness.

Mathematically, this can be expressed as:

$$I_{\text{diffused}} = \sum I_i \frac{\langle \vec{L_i}, \vec{N} \rangle}{\|\vec{L_i}\| \|\vec{N}\|},$$

where 

- $ I_{\text{diffused}} $ is the intensity due to diffuse reflection,
- $ I_i $ is the intensity of the $ i^{\text{th}} $ light source, which can be either a point source or a directional light,
- $ \vec{L_i} $ is the directional vector of the $ i^{\text{th}} $ light source.

Algorithm 

function calculateDiffuseIntensity(normalVector, lightVector, incomingIntensity) 
    // Calculate the dot product of the normal vector and the light vector
    dotProduct = calculateDotProduct(normalVector, lightVector) 
    
    // Initialize diffuse intensity
    diffuseIntensity = 0.0 
    
    // Check if the dot product is greater than zero
    if dotProduct > 0 then 
        // Calculate the diffuse intensity based on the incoming intensity and the angle between the vectors
        diffuseIntensity = incomingIntensity + (incomingIntensity * dotProduct) / (calculateMagnitude(lightVector) * calculateMagnitude(normalVector))
    else 
        // If the dot product is not greater than zero, keep the diffuse intensity as the initial value
        diffuseIntensity = incomingIntensity 
    end if 
    
    // Return the calculated diffuse intensity
    return diffuseIntensity 
end function

Specular reflection

To model it, we use the simple fact that the angle made by the incident ray with the normal is equal to the angle made by the reflected ray with the normal.

![intensity_of_specular](./figs/intensityspecular.png)

Here

- $\vec{L}$ is the directional vector of light pointing from point $P$ on the surface to the point light source.
- $\vec{R}$ is the reflected light, which makes the same angle with $\vec{N}$ as $\vec{L}$.
- $\vec{V}$ is the view vector from point $P$ on the surface to the camera.
- $\vec{N}$ is the normal vector.

First, we express $\vec{R}$ in terms of $\vec{L}$ and $\vec{N}$.

We know that $\vec{L}$ can be split into two components: one parallel to $\vec{N}$ and another perpendicular to it.

$\vec{L_{\| \vec{N}}} = \langle \vec{L}, \hat{N} \rangle \hat{N}$

Since 

$\vec{L_{\| \vec{N}}} + \vec{L_{\perp \vec{N}}} = \vec{L}$

we have

$\implies \vec{L_{\perp \vec{N}}} = \vec{L} - \langle \vec{L}, \hat{N} \rangle \hat{N}$

Thus, we can express $\vec{R}$ as:

$\vec{R} = \vec{L_{\| \vec{N}}} - \vec{L_{\perp \vec{N}}$

$\implies \vec{R} = 2 \langle \vec{L}, \hat{N} \rangle \hat{N} - \vec{L}$

Now we determine the intensity due to specular reflection. For $\theta = 0$, the reflected vector and the view vector align, so brightness is at its maximum. If $\theta = 90^\circ$, no component of the reflected ray is in the direction of the view vector, so brightness is zero in this case.

For $0 \leq \theta \leq 90^\circ$, we use $\cos \theta$ to model brightness. We define $s$ to vary the shininess of different objects.

Then, the final expression for brightness due to specular reflection is:

$I_{\text{specular}} = \sum I_i (\cos \theta)^s = \sum I_i \left( \frac{\langle \vec{R_i}, \vec{V_i} \rangle}{\|\vec{R_i}\| \|\vec{V_i}\|} \right)^s$

Note that if $\theta > 90^\circ$, we might get a negative total intensity, which doesn't make sense. In those cases, we set the term to zero as before.

Combining both diffuse and specular brightness, along with ambient light, we get:

$I_{\text{total}} = I_a + \sum I_i \left[ \frac{\langle \vec{L_i}, \vec{N} \rangle}{\|\vec{L}_i\| \|\vec{N}\|} + \left( \frac{\langle \vec{R_i}, \vec{V} \rangle}{\|\vec{R_i}\| \|\vec{V}\|} \right)^s \right]$

Here

- $I_{\text{total}}$ is the total intensity at the point.
- $I_a$ is the intensity of ambient light.
- $I_i$ is the intensity of the $i$-th light, which could be a point source or directional.
- $\vec{L_i}$ is the incident vector of the $i$-th light.
- $\vec{R_i}$ is the reflected vector of the $i$-th light.
- $\vec{N}$ is the normal vector at the point.
- $\vec{V}$ is the view vector at the point.

Algorithm 

function calculateSpecularIntensity(observerPosition, intersectionPoint, normalVector, lightDirection, lightIntensity, shininess, currentIntensity) 
    reflectedRay = calculateReflectedRay(normalVector, lightDirection) 
    viewVector = subtractVectors(observerPosition, intersectionPoint) 
    reflectionViewDotProduct = dotProduct(reflectedRay, viewVector) 
    specularIntensity = 0.0 

    if reflectionViewDotProduct > 0.0 and shininess > 0 then 
        specularIntensity = currentIntensity + lightIntensity * (reflectionViewDotProduct / (vectorMagnitude(reflectedRay) * vectorMagnitude(viewVector))) ^ shininess 
    else 
        specularIntensity = currentIntensity 
    end if

    return specularIntensity 
end function

Shadows 

A shadow is the obstruction of light by one or more objects at a point.

What this means for us is that we need to check if a particular light source, such as a point source or directional light, intersects any other object in the scene before reaching the point for which we are calculating illumination due to that light. If that intersection occurs, then we do not include that light's intensity in the calculation of the total intensity; otherwise, we do.

In order to do that, we shoot a ray from the point of interest (for which we want to know whether it is shadowed) in the direction of the light source.

That ray is represented as 

$\vec{R} = P + t \vec{L}$

Here

- $P$ is the point of interest.
- $\vec{L}$ is the ray of light from $P$ toward the light source.
- $t$ is the parameter. For a point source, $t \in [0^+, 1]$ (at $t = 1$, we reach the light source itself), and for directional light, $t \in [0^+, \infty)$. We know that a point on a sphere will definitely intersect itself, so practically we take $0.0001$ instead of $0^+$. (I tried using `\epsilon_{\text{float}}` and the results were not visually appealing, so to speak.)

Next, we find the closest intersection of the sphere with the ray in the suitable range. If a sphere exists, then only ambient light illuminates that point; otherwise, both specular and diffuse reflections also occur.

Mirror Reflection

After a ray from a camera intersects at a point on an object, we find the reflected ray at that point (including its color) and then shoot a reflected ray to determine if it intersects another object and calculate the resulting color. We can do this as many times as we like (but usually, after three reflections, we observe diminishing returns per computation). Eventually, we take a weighted sum of all the colors, utilizing the `rfl` property of spheres.

Total Intensity of Light

Here, we combine all the effects, such as different kinds of reflection, into a single function, except for mirror reflection, which is handled through the ray tracing code itself.

Algorithm

function tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList, currentIntensity) 
    if lightList is not empty then 
        lightSource = lightList[0] // Get the first light source
        remainingLights = lightList[1:] // Get the rest of the light sources

        cumulativeIntensity = 0.0 
        maxDistance = 0.0 

        if lightSource.type == 'ambient' then 
            cumulativeIntensity = lightSource.intensity + cumulativeIntensity 
        else 
            lightDirection = {x: 0.0, y: 0.0, z: 0.0} 
            if lightSource.type == 'point' then 
                lightDirection = subtractVectors(lightSource.position, intersectionPoint) 
                maxDistance = 1.0 
            else 
                lightDirection = lightSource.position 
                maxDistance = infinity 
            end if

            shadowSphere, _ = findClosestSphere(intersectionPoint, lightDirection, 0.0001, maxDistance, sphereList) 

            if shadowSphere is None then 
                unitNormalVector = scaleVector(1.0 / vectorMagnitude(normalVector), normalVector) 
                cumulativeIntensity = calculateSpecularIntensity(observerPosition, intersectionPoint, unitNormalVector, lightDirection, lightSource.intensity, surfaceProperties, cumulativeIntensity) 
                cumulativeIntensity = calculateDiffuseIntensity(normalVector, lightDirection, lightSource.intensity, cumulativeIntensity) 
            end if
        end if

        return tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, remainingLights, sphereList, currentIntensity + cumulativeIntensity) 
    else 
        return currentIntensity 
    end if
end function

function til(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList) 
    return tilInner(normalVector, intersectionPoint, observerPosition, surfaceProperties, lightList, sphereList, 0.0) 
end function


    normalVector: The normal vector at the intersection point.
    intersectionPoint: The point where the ray intersects the surface.
    observerPosition: The position of the observer (camera).
    surfaceProperties: Properties of the surface being shaded.
    lightList: A list of light sources affecting the scene.
    sphereList: A list of spheres in the scene.
    currentIntensity: The accumulated intensity of light at the intersection point.
    lightSource: The current light source being processed.
    remainingLights: The remaining light sources after the first one.
    cumulativeIntensity: The intensity contributed by the current light source.
    maxDistance: The maximum distance for shadow calculations.
    lightDirection: The direction vector from the light source to the intersection point.
    shadowSphere: The closest sphere found in the shadow calculation.
    unitNormalVector: The normalized normal vector at the intersection point.
    calculateSpecularIntensity: A function that calculates the specular intensity contribution.
    calculateDiffuseIntensity: A function that calculates the diffuse intensity contribution.
    findClosestSphere: A function that finds the closest sphere to a point in a given direction.


Ray tracing algorithm

function extract(sphereOption, intensity) 
    if sphereOption is Some sphere then 
        return intensity
    else 
        return 0.0
    end if
end function

function rayTraceInner(origin, direction, minDistance, maxDistance, sceneLights, lightList, recursionLimit) 
    objIntensity = 0.0 
    otherIntensity = 0.0 

    closestSphere, intersectionParameter = findClosestSphere(origin, direction, minDistance, maxDistance, sceneLights)

    if closestSphere is Some sphere and intersectionParameter is Some tParameter then 
        intersectionPoint = addVectors(origin, scaleVector(tParameter, direction)) 
        normalVector = subtractVectors(intersectionPoint, sphere.center) 
        objIntensity = calculateLightIntensity(normalVector, intersectionPoint, origin, sphere.surfaceReflectivity, lightList, sceneLights)

        if sphere.reflectionCoefficient > 0.0 and recursionLimit > 0 then 
            reflectedRay = calculateReflectedRay(scaleVector(1.0 / vectorMagnitude(normalVector), normalVector), scaleVector(-1.0, direction)) 
            otherIntensity = extract(rayTraceInner(intersectionPoint, reflectedRay, 0.001, infinity, sceneLights, lightList, recursionLimit - 1))
            objIntensity = objIntensity * (1.0 - sphere.reflectionCoefficient) + sphere.reflectionCoefficient * otherIntensity
        end if
    end if 

    return closestSphere, objIntensity
end function

function rayTrace(origin, direction, minDistance, maxDistance, sceneLights, lightList) 
    return getSphereColor(rayTraceInner(origin, direction, minDistance, maxDistance, sceneLights, lightList, 3))
end function

Explanation of Variables:

    sphereOption: Represents an optional sphere object.
    intensity: The intensity of light at a point.
    origin: The starting point of the ray.
    direction: The direction of the ray.
    minDistance: The minimum distance for ray intersection.
    maxDistance: The maximum distance for ray intersection.
    sceneLights: The lights present in the scene.
    lightList: A list of lights affecting the scene.
    recursionLimit: The maximum number of recursive reflections allowed.
    closestSphere: The closest sphere found in the scene.
    intersectionParameter: The parameter at which the ray intersects the sphere.
    intersectionPoint: The point where the ray intersects the sphere.
    normalVector: The normal vector at the intersection point.
    objIntensity: The intensity of light from the object.
    otherIntensity: The intensity of light from reflections.
    reflectedRay: The direction of the reflected ray.
    getSphereColor: A function that retrieves the color of the sphere based on the computed intensity.
